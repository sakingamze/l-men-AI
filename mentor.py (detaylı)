# Bu versiyonda daha kompleks bir mentorluk algoritması deniyorum. 
#Gece yarısı yapılan son güncellemelerle birlikte bazı çakışmalar oluştu.
#Bu kısımları, projenin potansiyelini ve hedeflediğim derinliği görmeniz adına silmeden bırakıyorum. 
#07.11.25 
import os
import ast
import time
import sqlite3
import hashlib
import traceback
from typing import List, Tuple, Optional

import streamlit as st
import matplotlib.pyplot as plt
from google import genai

from auth import create_user_table, register_user, login_user
from pdf_report import generate_pdf


UI = {
    "login_ok": "Giriş başarılı. Hoş geldin, {user}.",
    "login_fail": "Giriş bilgileri hatalı görünüyor. Tekrar kontrol edebilir misin?",
    "register_ok": "Kayıt tamam. Artık giriş yapabilirsin: {user}",
    "register_fail": "Bu kullanıcı adı kullanılıyor. Başka bir tane deneyelim.",
    "empty_code": "Analiz için bir kod paylaşman gerekiyor.",
    "pdf_fail": "PDF raporu şu an üretilemedi. (pdf_report.py tarafını kontrol etmek gerekebilir.)",
    "msg_sent": "Mesaj gönderildi.",
    "msg_empty": "Mesaj boş olmasın.",
    "room_joined": "Gruba katıldın.",
    "room_created": "Grup oluşturuldu.",
    "saved": "Kaydedildi.",
    "match_wait": "Şu an uygun eşleşme yok. Birazdan tekrar deneyebilirsin.",
    "match_done": "Eşleşme hazır. Mesajlar bölümünden devam edebilirsin.",
    "waiting_removed": "Tamam. Beklemedeysen listeden çıkarıldın.",
}

st.set_page_config(page_title="Lümen-AI", page_icon="✨", layout="wide")

# CSS: tema + input + select dropdown + header/toolbar + sidebar
st.markdown("""
<style>
:root{
  --bg:#F5F1E8;
  --card:#FFF9F0;
  --field:#FFFCF6;
  --text:#1F1F1F;
  --indigo:#2E2A62;
  --indigo2:#3D3A7A;
  --mustard:#C9A227;
  --border:#D6CCBB;
  --shadow:0 10px 25px rgba(0,0,0,.06);
}

html, body, .stApp, [data-testid="stAppViewContainer"]{
  background:var(--bg) !important;
  color:var(--text) !important;
}

h1,h2,h3{ color:var(--indigo) !important; }
label{ color:var(--mustard) !important; font-weight:700 !important; }

.lumen-card{
  background:var(--card);
  border:1px solid var(--border);
  border-radius:16px;
  padding:16px;
  box-shadow:var(--shadow);
}

.stTextInput input,
.stTextArea textarea{
  background:var(--field) !important;
  color:var(--text) !important;
  border:1px solid var(--border) !important;
  border-radius:12px !important;
  caret-color: var(--mustard) !important;
}

.stTextInput input:focus,
.stTextArea textarea:focus{
  outline:none !important;
  box-shadow:0 0 0 3px rgba(201,162,39,0.25) !important;
  border-color: rgba(201,162,39,0.7) !important;
}

[data-baseweb="select"] > div{
  background:var(--field) !important;
  border:1px solid var(--border) !important;
  border-radius:12px !important;
}

/* dropdown listbox */
ul[role="listbox"] {
  background: var(--card) !important;
  border: 1px solid var(--border) !important;
}
ul[role="listbox"] li { color: var(--text) !important; }
ul[role="listbox"] li:hover { background: rgba(201,162,39,0.18) !important; }

.stButton>button{
  background:var(--indigo) !important;
  color:#fff !important;
  border-radius:12px !important;
  font-weight:800 !important;
}
.stButton>button:hover{ background:var(--indigo2) !important; }

.stDownloadButton>button{
  background:var(--mustard) !important;
  color:#1A1A1A !important;
  border-radius:12px !important;
  font-weight:900 !important;
}

/* sidebar + top bars */
[data-testid="stSidebar"]{
  background:#FBF6ED !important;
  border-right:1px solid var(--border) !important;
}
header[data-testid="stHeader"]{ background: var(--bg) !important; }
div[data-testid="stToolbar"]{ background: transparent !important; }
</style>
""", unsafe_allow_html=True)

DB_NAME = "lumen.db"

def conn():
    return sqlite3.connect(DB_NAME, check_same_thread=False)

def now_ts() -> int:
    return int(time.time())

def fmt_ts(ts: int) -> str:
    try:
        return time.strftime("%Y-%m-%d %H:%M", time.localtime(ts))
    except Exception:
        return str(ts)

def safe_text(s: str, limit: int = 4000) -> str:
    return (s or "").strip()[:limit]

def sha(s: str) -> str:
    return hashlib.sha256(s.encode("utf-8")).hexdigest()

def init_tables():
    con = conn()
    cur = con.cursor()

    cur.execute("""
    CREATE TABLE IF NOT EXISTS profiles (
        username TEXT PRIMARY KEY,
        display_name TEXT,
        bio TEXT,
        avatar BLOB,
        updated_at INTEGER,
        gender TEXT
    )
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS follows (
        follower TEXT NOT NULL,
        following TEXT NOT NULL,
        created_at INTEGER NOT NULL,
        UNIQUE(follower, following)
    )
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS dm_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        sender TEXT NOT NULL,
        receiver TEXT NOT NULL,
        body TEXT NOT NULL,
        created_at INTEGER NOT NULL,
        is_read INTEGER NOT NULL DEFAULT 0
    )
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS analyses (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT NOT NULL,
        created_at INTEGER NOT NULL,
        language TEXT NOT NULL,
        level TEXT NOT NULL,
        tone TEXT NOT NULL,
        local_summary TEXT,
        ai_summary TEXT
    )
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS rooms (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        owner TEXT NOT NULL,
        title TEXT NOT NULL,
        description TEXT,
        created_at INTEGER NOT NULL,
        is_open INTEGER NOT NULL DEFAULT 1
    )
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS room_members (
        room_id INTEGER NOT NULL,
        username TEXT NOT NULL,
        joined_at INTEGER NOT NULL,
        UNIQUE(room_id, username)
    )
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS room_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        room_id INTEGER NOT NULL,
        sender TEXT NOT NULL,
        body TEXT NOT NULL,
        created_at INTEGER NOT NULL
    )
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS room_reads (
        room_id INTEGER NOT NULL,
        username TEXT NOT NULL,
        last_seen_at INTEGER NOT NULL,
        UNIQUE(room_id, username)
    )
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS match_queue (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT NOT NULL,
        error_key TEXT NOT NULL,
        match_mode TEXT NOT NULL,
        gender_pref TEXT NOT NULL,
        created_at INTEGER NOT NULL,
        status TEXT NOT NULL DEFAULT 'waiting'
    )
    """)

    con.commit()
    con.close()

# ---- profile
def get_profile(username: str):
    con = conn()
    cur = con.cursor()
    cur.execute("SELECT username, display_name, bio, avatar, updated_at, gender FROM profiles WHERE username=?", (username,))
    row = cur.fetchone()
    con.close()
    return row

def upsert_profile(username: str, display_name: str, bio: str, avatar_bytes: Optional[bytes], gender: str):
    con = conn()
    cur = con.cursor()
    cur.execute("SELECT 1 FROM profiles WHERE username=? LIMIT 1", (username,))
    exists = cur.fetchone()

    if exists:
        if avatar_bytes is None:
            cur.execute("""
                UPDATE profiles SET display_name=?, bio=?, gender=?, updated_at=?
                WHERE username=?
            """, (display_name, bio, gender, now_ts(), username))
        else:
            cur.execute("""
                UPDATE profiles SET display_name=?, bio=?, avatar=?, gender=?, updated_at=?
                WHERE username=?
            """, (display_name, bio, avatar_bytes, gender, now_ts(), username))
    else:
        cur.execute("""
            INSERT INTO profiles (username, display_name, bio, avatar, updated_at, gender)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (username, display_name, bio, avatar_bytes, now_ts(), gender))

    con.commit()
    con.close()

def get_user_gender(username: str) -> str:
    prof = get_profile(username)
    if not prof:
        return "unspecified"
    return prof[5] or "unspecified"

# ---- follow
def follow(follower: str, following: str):
    if follower == following:
        return
    con = conn()
    cur = con.cursor()
    cur.execute("""
        INSERT OR IGNORE INTO follows (follower, following, created_at)
        VALUES (?, ?, ?)
    """, (follower, following, now_ts()))
    con.commit()
    con.close()

def unfollow(follower: str, following: str):
    con = conn()
    cur = con.cursor()
    cur.execute("DELETE FROM follows WHERE follower=? AND following=?", (follower, following))
    con.commit()
    con.close()

def is_following(follower: str, following: str) -> bool:
    con = conn()
    cur = con.cursor()
    cur.execute("SELECT 1 FROM follows WHERE follower=? AND following=? LIMIT 1", (follower, following))
    row = cur.fetchone()
    con.close()
    return bool(row)

def followers_of(user: str, limit: int = 50):
    con = conn()
    cur = con.cursor()
    cur.execute("""
        SELECT follower, created_at
        FROM follows
        WHERE following=?
        ORDER BY created_at DESC
        LIMIT ?
    """, (user, limit))
    rows = cur.fetchall()
    con.close()
    return rows

def following_of(user: str, limit: int = 50):
    con = conn()
    cur = con.cursor()
    cur.execute("""
        SELECT following, created_at
        FROM follows
        WHERE follower=?
        ORDER BY created_at DESC
        LIMIT ?
    """, (user, limit))
    rows = cur.fetchall()
    con.close()
    return rows

# ---- DM
def send_dm(sender: str, receiver: str, body: str):
    receiver = (receiver or "").strip()
    body = safe_text(body, 4000)
    if not receiver or not body:
        return
    con = conn()
    cur = con.cursor()
    cur.execute("""
        INSERT INTO dm_messages (sender, receiver, body, created_at, is_read)
        VALUES (?, ?, ?, ?, 0)
    """, (sender, receiver, body, now_ts()))
    con.commit()
    con.close()

def list_dm_partners(username: str, limit: int = 30):
    con = conn()
    cur = con.cursor()
    cur.execute("""
        SELECT other, MAX(created_at) as last_ts FROM (
            SELECT receiver as other, created_at FROM dm_messages WHERE sender=?
            UNION ALL
            SELECT sender as other, created_at FROM dm_messages WHERE receiver=?
        )
        GROUP BY other
        ORDER BY last_ts DESC
        LIMIT ?
    """, (username, username, limit))
    rows = cur.fetchall()
    con.close()
    return rows

def fetch_thread(a: str, b: str, limit: int = 120):
    con = conn()
    cur = con.cursor()
    cur.execute("""
        SELECT sender, receiver, body, created_at, is_read
        FROM dm_messages
        WHERE (sender=? AND receiver=?) OR (sender=? AND receiver=?)
        ORDER BY created_at ASC
        LIMIT ?
    """, (a, b, b, a, limit))
    rows = cur.fetchall()
    con.close()
    return rows

def mark_thread_read(current_user: str, other: str):
    con = conn()
    cur = con.cursor()
    cur.execute("""
        UPDATE dm_messages
        SET is_read=1
        WHERE sender=? AND receiver=? AND is_read=0
    """, (other, current_user))
    con.commit()
    con.close()

def unread_dm_count(username: str) -> int:
    con = conn()
    cur = con.cursor()
    cur.execute("SELECT COUNT(*) FROM dm_messages WHERE receiver=? AND is_read=0", (username,))
    n = cur.fetchone()[0]
    con.close()
    return int(n)

# ---- Rooms
def create_room(owner: str, title: str, description: str):
    con = conn()
    cur = con.cursor()
    cur.execute("""
        INSERT INTO rooms (owner, title, description, created_at, is_open)
        VALUES (?, ?, ?, ?, 1)
    """, (owner, title.strip(), safe_text(description, 1000), now_ts()))
    room_id = cur.lastrowid

    cur.execute("""
        INSERT OR IGNORE INTO room_members (room_id, username, joined_at)
        VALUES (?, ?, ?)
    """, (room_id, owner, now_ts()))

    cur.execute("""
        INSERT OR REPLACE INTO room_reads (room_id, username, last_seen_at)
        VALUES (?, ?, ?)
    """, (room_id, owner, now_ts()))

    con.commit()
    con.close()
    return room_id

def list_rooms(open_only: bool = True, limit: int = 50):
    con = conn()
    cur = con.cursor()
    if open_only:
        cur.execute("""
            SELECT id, owner, title, description, created_at
            FROM rooms
            WHERE is_open=1
            ORDER BY created_at DESC
            LIMIT ?
        """, (limit,))
    else:
        cur.execute("""
            SELECT id, owner, title, description, created_at
            FROM rooms
            ORDER BY created_at DESC
            LIMIT ?
        """, (limit,))
    rows = cur.fetchall()
    con.close()
    return rows

def join_room(room_id: int, username: str):
    con = conn()
    cur = con.cursor()
    cur.execute("""
        INSERT OR IGNORE INTO room_members (room_id, username, joined_at)
        VALUES (?, ?, ?)
    """, (room_id, username, now_ts()))
    cur.execute("""
        INSERT OR IGNORE INTO room_reads (room_id, username, last_seen_at)
        VALUES (?, ?, ?)
    """, (room_id, username, now_ts()))
    con.commit()
    con.close()

def list_my_rooms(username: str, limit: int = 50):
    con = conn()
    cur = con.cursor()
    cur.execute("""
        SELECT r.id, r.title, r.owner, r.created_at
        FROM rooms r
        JOIN room_members m ON m.room_id = r.id
        WHERE m.username = ?
        ORDER BY r.created_at DESC
        LIMIT ?
    """, (username, limit))
    rows = cur.fetchall()
    con.close()
    return rows

def send_room_message(room_id: int, sender: str, body: str):
    body = safe_text(body, 2000)
    if not body:
        return
    con = conn()
    cur = con.cursor()
    cur.execute("""
        INSERT INTO room_messages (room_id, sender, body, created_at)
        VALUES (?, ?, ?, ?)
    """, (room_id, sender, body, now_ts()))
    con.commit()
    con.close()

def get_room_messages(room_id: int, limit: int = 120):
    con = conn()
    cur = con.cursor()
    cur.execute("""
        SELECT sender, body, created_at
        FROM room_messages
        WHERE room_id=?
        ORDER BY created_at DESC
        LIMIT ?
    """, (room_id, limit))
    rows = cur.fetchall()
    con.close()
    return list(reversed(rows))

def set_room_seen(room_id: int, username: str):
    con = conn()
    cur = con.cursor()
    cur.execute("""
        INSERT OR REPLACE INTO room_reads (room_id, username, last_seen_at)
        VALUES (?, ?, ?)
    """, (room_id, username, now_ts()))
    con.commit()
    con.close()

def unread_room_count(username: str) -> int:
    con = conn()
    cur = con.cursor()
    cur.execute("""
        SELECT COUNT(*)
        FROM room_members m
        JOIN room_reads rr ON rr.room_id = m.room_id AND rr.username = m.username
        JOIN room_messages rm ON rm.room_id = m.room_id AND rm.created_at > rr.last_seen_at
        WHERE m.username = ?
    """, (username,))
    n = cur.fetchone()[0]
    con.close()
    return int(n)

# ---- Analyses
def save_analysis(username: str, language: str, level: str, tone: str,
                  local_summary: str, ai_summary: str):
    con = conn()
    cur = con.cursor()
    cur.execute("""
        INSERT INTO analyses (username, created_at, language, level, tone, local_summary, ai_summary)
        VALUES (?, ?, ?, ?, ?, ?, ?)
    """, (username, now_ts(), language, level, tone, safe_text(local_summary, 400), safe_text(ai_summary, 12000)))
    con.commit()
    con.close()

def list_user_analyses(username: str, limit: int = 30):
    con = conn()
    cur = con.cursor()
    cur.execute("""
        SELECT id, created_at, language, level, tone, local_summary, ai_summary
        FROM analyses
        WHERE username=?
        ORDER BY created_at DESC
        LIMIT ?
    """, (username, limit))
    rows = cur.fetchall()
    con.close()
    return rows

# ---- Matching
def make_error_key(language: str, findings: List[Tuple[str, str]], ai_text: str) -> str:
    day = time.strftime("%Y-%m-%d", time.localtime(now_ts()))
    base = [language.lower(), day]
    cats = sorted({c.lower().strip() for c, _ in findings}) if findings else ["general"]
    base.extend(cats)
    t = (ai_text or "").lower()
    for k in ["syntax", "mantık", "performans", "güvenlik", "undefined", "null", "type", "exception", "api", "auth"]:
        if k in t:
            base.append(k)
    return sha("|".join(base))

def enqueue_match(username: str, error_key: str, match_mode: str, gender_pref: str):
    con = conn()
    cur = con.cursor()
    cur.execute("""
        SELECT 1 FROM match_queue
        WHERE username=? AND error_key=? AND status='waiting'
        LIMIT 1
    """, (username, error_key))
    if not cur.fetchone():
        cur.execute("""
            INSERT INTO match_queue (username, error_key, match_mode, gender_pref, created_at, status)
            VALUES (?, ?, ?, ?, ?, 'waiting')
        """, (username, error_key, match_mode, gender_pref, now_ts()))
        con.commit()
    con.close()

def cancel_waiting(username: str, error_key: str):
    con = conn()
    cur = con.cursor()
    cur.execute("""
        UPDATE match_queue SET status='cancelled'
        WHERE username=? AND error_key=? AND status='waiting'
    """, (username, error_key))
    con.commit()
    con.close()

def compatible(pref: str, gender: str) -> bool:
    if pref == "any":
        return True
    if gender == "unspecified":
        return True
    return pref == gender

def find_waiting_candidates(current_user: str, error_key: str, match_mode: str, my_pref: str, limit: int = 30):
    con = conn()
    cur = con.cursor()
    cur.execute("""
        SELECT username, gender_pref, created_at
        FROM match_queue
        WHERE error_key=? AND status='waiting'
          AND username != ?
          AND match_mode=?
        ORDER BY created_at ASC
        LIMIT ?
    """, (error_key, current_user, match_mode, limit))
    rows = cur.fetchall()
    con.close()

    my_gender = get_user_gender(current_user)
    ok = []
    for u, u_pref, _ in rows:
        u_gender = get_user_gender(u)
        if compatible(my_pref, u_gender) and compatible(u_pref, my_gender):
            ok.append(u)
    return ok

def mark_matched(usernames: List[str], error_key: str):
    if not usernames:
        return
    con = conn()
    cur = con.cursor()
    ph = ",".join(["?"] * len(usernames))
    cur.execute(
        f"""
        UPDATE match_queue
        SET status='matched'
        WHERE error_key=? AND status='waiting' AND username IN ({ph})
        """,
        (error_key, *usernames)
    )
    con.commit()
    con.close()

# ---- Local analyzer
class CodeAnalyzer:
    def _init_(self, code: str):
        self.code = code
        self.findings: List[Tuple[str, str]] = []

    def run(self):
        try:
            ast.parse(self.code)
        except SyntaxError as e:
            self.findings.append(("Syntax", f"Syntax hatası: {e}"))

        risky = ["eval(", "exec(", "os.system", "subprocess", "pickle.load", "pickle.loads"]
        for r in risky:
            if r in self.code:
                self.findings.append(("Güvenlik", f"Riskli kullanım: {r}"))

        if "range(len(" in self.code:
            self.findings.append(("Performans", "range(len(...)) yerine enumerate daha temiz olur."))

        if "== True" in self.code or "== False" in self.code:
            self.findings.append(("Mantık", "if x == True/False yerine if x / if not x tercih edilir."))

        return self.findings

def character_rules(name: str) -> str:
    rules = {
        "Samimi ve Nazik": "Nazik ve sakin konuş. Kısa anlat, yargılama.",
        "Net ve Profesyonel": "Kısa ve net konuş. Önce sorun, sonra çözüm.",
        "Disiplinli ama Kibar": "Net ol ama kırıcı olma. Sorun + çözüm yan yana.",
        "Rahat ve Pratik": "Günlük bir dille anlat. Pratik öneri ver.",
        "Öğretmen gibi": "Adım adım anlat. En sonda kısa özet yap."
    }
    return rules.get(name, rules["Samimi ve Nazik"])

# ---- init
create_user_table()
init_tables()

if "logged_in" not in st.session_state:
    st.session_state.logged_in = False
if "user" not in st.session_state:
    st.session_state.user = None
if "dm_to" not in st.session_state:
    st.session_state.dm_to = ""

# ---- sidebar
with st.sidebar:
    st.markdown("## Lümen-AI")
    st.caption("Bej / indigo / hardal.")

    if st.session_state.logged_in and st.session_state.user:
        u = st.session_state.user
        dm_unread = unread_dm_count(u)
        room_unread = unread_room_count(u)

        st.write(f"Giriş yapan: {u}")
        st.write(f"Bildirim: DM {dm_unread} • Grup {room_unread}")

        st.divider()
        page = st.radio("Menü", ["Analiz", "Geçmiş", "Gruplar", "Mesajlar", "Profil"], index=0)

        if st.button("Çıkış Yap"):
            st.session_state.logged_in = False
            st.session_state.user = None
            st.rerun()
    else:
        page = "Login"

# ---- login
if page == "Login":
    st.markdown("<div class='lumen-card'>", unsafe_allow_html=True)
    st.title("Giriş")

    tab1, tab2 = st.tabs(["Giriş Yap", "Kayıt Ol"])

    with tab1:
        username = st.text_input("Kullanıcı adı")
        password = st.text_input("Şifre", type="password")

        if st.button("Giriş"):
            if login_user(username, password):
                st.session_state.logged_in = True
                st.session_state.user = username
                if not get_profile(username):
                    upsert_profile(username, username, "", None, "unspecified")
                st.success(UI["login_ok"].format(user=username))
                st.rerun()
            else:
                st.error(UI["login_fail"])

    with tab2:
        new_user = st.text_input("Yeni kullanıcı adı")
        new_pass = st.text_input("Yeni şifre", type="password")
        if st.button("Kayıt Ol"):
            if register_user(new_user, new_pass):
                if not get_profile(new_user):
                    upsert_profile(new_user, new_user, "", None, "unspecified")
                st.success(UI["register_ok"].format(user=new_user))
            else:
                st.error(UI["register_fail"])

    st.markdown("</div>", unsafe_allow_html=True)
    st.stop()

# ---- AI client
api_key = os.getenv("GEMINI_API_KEY", "").strip()
client = genai.Client(api_key=api_key) if api_key else genai.Client()
MODEL_NAME = "models/gemini-2.5-flash"
current_user = st.session_state.user

# =========================
# Pages
# =========================
if page == "Analiz":
    st.title("Lümen-AI")
    st.caption("Kodunu bırak, birlikte bakalım.")

    st.markdown("<div class='lumen-card'>", unsafe_allow_html=True)
    c1, c2, c3 = st.columns(3)
    with c1:
        level = st.selectbox("Seviye", ["Junior", "Senior"])
    with c2:
        tone = st.selectbox("Üslup", ["Samimi ve Nazik", "Net ve Profesyonel", "Disiplinli ama Kibar", "Rahat ve Pratik", "Öğretmen gibi"])
    with c3:
        language = st.selectbox("Kod dili", ["Python", "JavaScript", "Java", "C#"])
    st.markdown("</div>", unsafe_allow_html=True)

    left, right = st.columns(2, gap="large")

    with left:
        st.markdown("<div class='lumen-card'>", unsafe_allow_html=True)
        st.subheader("Kod")
        code_input = st.text_area("Analiz edilecek kodu buraya yapıştır:", height=360)
        analyze_button = st.button("Analiz Et")
        st.markdown("</div>", unsafe_allow_html=True)

    with right:
        st.markdown("<div class='lumen-card'>", unsafe_allow_html=True)
        st.subheader("Mentör notları")

        if analyze_button and not code_input.strip():
            st.warning(UI["empty_code"])

        elif analyze_button and code_input.strip():
            try:
                findings: List[Tuple[str, str]] = []
                if language == "Python":
                    findings = CodeAnalyzer(code_input).run()

                local_summary = " / ".join(sorted({c for c, _ in findings})) if findings else "Lokal not yok."
                local_note = "\n".join([f"- {k}: {m}" for k, m in findings]) or "- Lokal not: Kayda değer bir şey yakalayamadım."

                prompt = f"""
Sen deneyimli bir yazılım mentörüsün.

Seviye: {level}
Kod dili: {language}
Üslup: {tone} ({character_rules(tone)})

Lokal notlar (varsa):
{local_note}

İstek:
- Sorunları kısa ve net yaz (Syntax / Mantık / Performans / Güvenlik)
- En önemli 3 iyileştirmeyi sırala
- Gerekirse kısa refactor örneği ver
- 2-4 test önerisi ekle
- 1-10 puan ver ve tek cümle gerekçe yaz
- Junior ise bir cümle moral ver (abartmadan)

Kod:
{code_input}
""".strip()

                response = client.models.generate_content(model=MODEL_NAME, contents=prompt)
                analysis_text = getattr(response, "text", "") or "AI cevap döndürmedi."

                st.markdown(analysis_text)
                save_analysis(current_user, language, level, tone, local_summary, analysis_text)

                if findings:
                    cats = ["Syntax", "Mantık", "Performans", "Güvenlik"]
                    counts = [sum(1 for k, _ in findings if k == cat) for cat in cats]
                    fig, ax = plt.subplots()
                    ax.bar(cats, counts)
                    ax.set_title("Lokal tespitler (Python)")
                    st.pyplot(fig)

                pdf_path = generate_pdf(username=current_user, role=level, analysis_text=analysis_text)
                if pdf_path and os.path.exists(pdf_path):
                    with open(pdf_path, "rb") as f:
                        st.download_button("PDF indir", f, file_name="lumen-rapor.pdf", mime="application/pdf")
                else:
                    st.info(UI["pdf_fail"])

                st.divider()
                st.subheader("Eşleşme")

                mode_ui = st.radio("Nasıl eşleşelim?", ["Bireysel", "Grup"], horizontal=True)
                match_mode = "solo" if mode_ui == "Bireysel" else "group"

                pref_ui = st.selectbox("Cinsiyet tercihi", ["Farketmez", "Kadın", "Erkek"])
                gender_pref = "any"
                if pref_ui == "Kadın":
                    gender_pref = "female"
                elif pref_ui == "Erkek":
                    gender_pref = "male"

                error_key = make_error_key(language, findings, analysis_text)

                colA, colB = st.columns([1, 1])
                with colA:
                    go = st.button("Eşleşmek istiyorum")
                with colB:
                    cancel = st.button("Beklemeden çık")

                if cancel:
                    cancel_waiting(current_user, error_key)
                    st.info(UI["waiting_removed"])

                if go:
                    enqueue_match(current_user, error_key, match_mode, gender_pref)
                    candidates = find_waiting_candidates(current_user, error_key, match_mode, gender_pref)

                    if match_mode == "solo":
                        if not candidates:
                            st.info(UI["match_wait"])
                        else:
                            partner = candidates[0]
                            mark_matched([current_user, partner], error_key)
                            st.success(UI["match_done"])
                            st.session_state.dm_to = partner
                    else:
                        group = [current_user] + candidates[:4]
                        if len(group) < 3:
                            st.info(UI["match_wait"])
                        else:
                            mark_matched(group, error_key)
                            room_id = create_room(current_user, "Aynı soruna takılanlar", "Benzer problem üzerinden otomatik oluştu.")
                            for u in group:
                                join_room(room_id, u)
                            send_room_message(room_id, "sistem", "Bu oda otomatik oluştu. Kısa bir özet yazın, sonra toparlarız.")
                            st.success(UI["match_done"])

            except Exception as e:
                st.error(str(e))
                st.code(traceback.format_exc())
        else:
            st.write("Kod girildiğinde sonuç burada görünecek.")

        st.markdown("</div>", unsafe_allow_html=True)


if page == "Geçmiş":
    st.title("Geçmiş")
    rows = list_user_analyses(current_user, limit=30)
    if not rows:
        st.info("Henüz kayıtlı analiz yok.")
    else:
        choices = []
        for rid, created_at, lang, lvl, tone, local_sum, ai_sum in rows:
            label = f"#{rid} • {fmt_ts(created_at)} • {lang} • {lvl} • {tone} • {local_sum}"
            choices.append((rid, label))
        picked = st.selectbox("Bir analiz seç:", choices, format_func=lambda x: x[1])
        rid = picked[0]
        for row in rows:
            if row[0] == rid:
                _, created_at, lang, lvl, tone, local_sum, ai_sum = row
                st.caption(f"{fmt_ts(created_at)} | {lang} | {lvl} | {tone}")
                st.write(f"Lokal not: {local_sum}")
                st.markdown(ai_sum)
                break

if page == "Gruplar":
    st.title("Gruplar")

    with st.expander("Yeni grup oluştur"):
        title = st.text_input("Grup adı", key="room_title")
        desc = st.text_area("Kısa açıklama", height=100, key="room_desc")
        if st.button("Grubu oluştur"):
            if title.strip():
                create_room(current_user, title, desc)
                st.success(UI["room_created"])
                st.rerun()
            else:
                st.warning("Grup adı boş kalmış.")

    st.divider()

    colL, colR = st.columns([1, 2], gap="large")

    with colL:
        st.subheader("Katıldığın gruplar")
        my_rooms = list_my_rooms(current_user, limit=50)
        selected_room = None
        if not my_rooms:
            st.write("Henüz yok.")
        else:
            selected_room = st.selectbox(
                "Seç",
                my_rooms,
                format_func=lambda r: f"#{r[0]} • {r[1]} (kurucu: {r[2]})"
            )

        st.divider()
        st.subheader("Açık gruplar")
        rooms = list_rooms(open_only=True, limit=50)
        if rooms:
            picked = st.selectbox("Katılmak istersen:", rooms, format_func=lambda r: f"#{r[0]} • {r[2]}")
            if st.button("Bu gruba katıl"):
                join_room(picked[0], current_user)
                st.success(UI["room_joined"])
                st.rerun()
        else:
            st.write("Şu an açık grup yok.")

    with colR:
        st.subheader("Oda sohbeti")
        if not selected_room:
            st.info("Soldan bir grup seç.")
        else:
            room_id, title, owner, created_at = selected_room
            st.caption(f"{title} • kurucu: {owner} • {fmt_ts(created_at)}")

            msgs = get_room_messages(room_id, limit=120)
            if msgs:
                for sender, body, ts in msgs:
                    st.write(f"[{fmt_ts(ts)}] {sender}: {body}")
            else:
                st.write("Henüz mesaj yok.")

            set_room_seen(room_id, current_user)

            msg_body = st.text_input("Mesaj", placeholder="Bir şey yaz...", key=f"room_msg_{room_id}")
            if st.button("Gönder", key=f"room_send_{room_id}"):
                if msg_body.strip():
                    send_room_message(room_id, current_user, msg_body)
                    st.rerun()
                else:
                    st.warning(UI["msg_empty"])

if page == "Mesajlar":
    st.title("Mesajlar")
    st.caption("Sohbeti açınca okunmamışlar sıfırlanır.")

    colL, colR = st.columns([1, 2], gap="large")

    with colL:
        st.subheader("Sohbetler")
        partners = list_dm_partners(current_user, limit=30)
        options = [""] + [p[0] for p in partners]
        other = st.selectbox("Seç", options, index=0)

        st.divider()
        st.subheader("Yeni mesaj")
        st.session_state.dm_to = st.text_input("Kime (kullanıcı adı)", value=other or st.session_state.dm_to)
        body = st.text_area("Mesaj", height=120)
        if st.button("Gönder"):
            if st.session_state.dm_to.strip() and body.strip():
                send_dm(current_user, st.session_state.dm_to.strip(), body)
                st.success(UI["msg_sent"])
                st.rerun()
            else:
                st.warning(UI["msg_empty"])

    with colR:
        st.subheader("Sohbet")
        target = (st.session_state.dm_to or "").strip()
        if not target:
            st.info("Soldan bir sohbet seç ya da kullanıcı adı yaz.")
        else:
            mark_thread_read(current_user, target)
            thread = fetch_thread(current_user, target, limit=120)
            if not thread:
                st.write("Henüz konuşma yok.")
            else:
                for s, r, b, ts, is_read in thread:
                    who = "sen" if s == current_user else s
                    st.write(f"[{fmt_ts(ts)}] {who}: {b}")

            st.divider()
            quick = st.text_input("Hızlı cevap", placeholder="Bir şey yaz...", key="dm_quick")
            if st.button("Yolla"):
                if quick.strip():
                    send_dm(current_user, target, quick)
                    st.success(UI["msg_sent"])
                    st.rerun()
                else:
                    st.warning(UI["msg_empty"])

if page == "Profil":
    st.title("Profil")

    tab_me, tab_other = st.tabs(["Ben", "Başkasına bak"])

    with tab_me:
        prof = get_profile(current_user)
        display_name = (prof[1] if prof else current_user) or current_user
        bio = (prof[2] if prof else "") or ""
        avatar = prof[3] if prof else None
        gender = (prof[5] if prof else "unspecified") or "unspecified"

        c1, c2 = st.columns([1, 2], gap="large")

        with c1:
            st.subheader("Foto")
            if avatar:
                st.image(avatar, width=140)
            up = st.file_uploader("Profil fotoğrafı", type=["png", "jpg", "jpeg"])
            avatar_bytes = up.read() if up is not None else None

        with c2:
            st.subheader("Bilgi")
            new_display = st.text_input("Görünen ad", value=display_name)
            new_bio = st.text_area("Kısaca", value=bio, height=120)

            gender_ui = st.selectbox(
                "Profil cinsiyeti",
                ["Belirtmek istemiyorum", "Kadın", "Erkek"],
                index=0 if gender == "unspecified" else 1 if gender == "female" else 2
            )
            gender_val = "unspecified"
            if gender_ui == "Kadın":
                gender_val = "female"
            elif gender_ui == "Erkek":
                gender_val = "male"

            if st.button("Kaydet"):
                upsert_profile(current_user, new_display.strip() or current_user, safe_text(new_bio, 500), avatar_bytes, gender_val)
                st.success(UI["saved"])
                st.rerun()

        st.divider()
        c3, c4 = st.columns(2)

        with c3:
            st.subheader("Takip ettiklerin")
            items = following_of(current_user, limit=50)
            if not items:
                st.write("Boş.")
            else:
                for u, ts in items:
                    st.write(f"- {u} ({fmt_ts(ts)})")

        with c4:
            st.subheader("Seni takip edenler")
            items = followers_of(current_user, limit=50)
            if not items:
                st.write("Boş.")
            else:
                for u, ts in items:
                    st.write(f"- {u} ({fmt_ts(ts)})")

    with tab_other:
        target = st.text_input("Kullanıcı adı", key="profile_lookup")
        if not target.strip():
            st.info("Bir kullanıcı adı yaz.")
        else:
            target = target.strip()
            prof = get_profile(target)
            if not prof:
                st.warning("Bu kullanıcı için profil bulunamadı.")
            else:
                _, dn, bio, avatar, updated, g = prof
                c1, c2 = st.columns([1, 2], gap="large")
                with c1:
                    if avatar:
                        st.image(avatar, width=140)
                    else:
                        st.write("Foto yok.")
                with c2:
                    st.subheader(dn or target)
                    if bio:
                        st.write(bio)
                    st.caption(f"Güncelleme: {fmt_ts(updated or 0)}")

                    if target != current_user:
                        if is_following(current_user, target):
                            if st.button("Takibi bırak"):
                                unfollow(current_user, target)
                                st.success(UI["saved"])
                                st.rerun()
                        else:
                            if st.button("Takip et"):
                                follow(current_user, target)
                                st.success(UI["saved"])
                                st.rerun()

                        st.divider()
                        st.subheader("Mesaj at")
                        msg = st.text_area("Mesaj", height=120, key="profile_dm")
                        if st.button("Gönder", key="profile_send"):
                            if msg.strip():
                                send_dm(current_user, target, msg)
                                st.success(UI["msg_sent"])
                                st.rerun()
                            else:
                                st.warning(UI["msg_empty"])
